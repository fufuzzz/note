#### 事务

- 四个特性
  - 原子性：所有操作要么成功，要么失败
  - 一致性：操作的前后，数据总的状态不会改变
  - 隔离性：对于多个用户并发访问数据库时，在一个事务中的能否读取到另外一个事务的数据
  - 持久性：事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作
- 操作
  - 开启事务：begin
  - 回滚事务：rollbck
  - 提交事务：commit

- 场景
  - 当涉及到多张表数据的修改，那么应该把这些功能看作一个整体，即要么一起成功，要么一起失败。



```
# 商品表
id name(商品名称) store(库存)  num(销量)  price(单价)

有价格必须用decimal(6, 2) 整数位长度是4,小数位长度是2

# 订单总表
id uid(用户id) order_code(订单号)  total_count(商品总数量) total_price(总价格)  status(状态,默认为1)

# 订单子表
id uid (用户id) order_code(订单号) gid(商品id)  count(商品的数量) price(商品单价)


```



#### 锁机制

- 悲观锁

  - 当查询某条记录时，即让数据库为该记录加锁，锁住记录后别人无法操作，使用类似如下语法

    ```python
    # 满足的条件
    # 1、必须在事务中使用
    # 2、select 后面加 for update
    select * from table where id=1 for update;
    
    # 数据库引擎
    - MYISAM 锁表
    - Innodb 锁行
    ```

  - 悲观锁类似于我们在多线程资源竞争时添加的互斥锁，容易出现死锁现象，采用不多。
  - 比如用户A给表A加了锁，然后查询表B。用户B给表B加了锁，然后查询表A。两个人同时等待对方操作完后，解除锁。这样就产生了死锁

- 乐观锁

  - 乐观锁并不是真实存在的锁，而是在更新的时候判断此时的某个字段的值是否是之前查询出的值，如果相同，表示没人修改，可以更新，否则表示别人抢过资源，不再执行更新。类似如下操作

    ```python
    update table set xx=xx where 字段=之前查询出该字段的值
    ```



#### 事务隔离级别

事务隔离级别指的是在处理同一个数据的多个事务中，一个事务修改数据后，其他事务何时能看到修改后的结果。

MySQL数据库事务隔离级别主要有四种：

- `Serializable`：串行化，一个事务一个事务的执行。
- `Repeatable read`：可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响。
- `Read committed`：读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值。
- `Read uncommitted`：读取未提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。
- MySQL数据库默认使用可重复读（ Repeatable read）。

修改方式：

```python
serializable 串行化
repeatable read 可重复读
read committed 读取已提交
read uncommitted 读取未提交

# 修改全局事务隔离级别
set global transaction isolation level read committed;

# 查看隔离级别
select @@global.transaction_isolation;
```



#### mysql优化之分库分表

- 分表
  - 垂直分表：把经常查询的字段放在一张表，把不经常查询的字段放在另外一张表
  - 水平分表
    - 按照范围：比如1-2000000存一张表，2000001-4000000存第二张表.......
    - 按照余数：事先估算需要多少张表，比如5张表，那么把自增id // 5 得到的余数 存储在 对应的表中

- 分库
  - 采用一致性hash算法
